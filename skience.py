from uncertainties import ufloat
import pickle
from astropy.cosmology import luminosity_distance
from astropysics.constants import c, me, h, hbar, kb, mp, e
from numpy import array

sb = 5.6704E-5
sigma_T = 6.6524E-25
keV2erg =1.60217646e-9


class skience(object):


    def __init__(self,scat=None,z=1.,Y=1.):
        '''
        Gerneral class for making the Gamma, Rph, R0
        calculations from different flux files
        
        The assumption in the readers is that there is
        a thermal and non-thermal flux measured


        '''
        if scat != None:
            kT = scat.GetParamArray("Black Body","kT")
            
            kTErr = kT[:,1]
            kT = kT[:,0]

            self.tt = kT > 0 

            self.kT =  map(lambda v,e: self._Convert2Ufloat(v,e),kT[self.tt],kTErr[self.tt])

        Mpc2cm =3.08567758E24
        
        self.Ld = (luminosity_distance(z)*Mpc2cm).value
        self.z=z
        self.Y=Y
        



    def ReadManually(self,totFlux,totFluxErr,bbFlux,bbFluxErr,kT=None,kTErr=None):

         self.energyFlux_tot = map(lambda v,e: self._Convert2Ufloat(v,e),totFlux[self.tt],totFluxErr[self.tt])
         self.energyFlux_bb = map(lambda v,e: self._Convert2Ufloat(v,e),bbFlux[self.tt],bbFluxErr[self.tt])
        
         
         self.kT = map(lambda v,e: self._Convert2Ufloat(v,e),kT[self.tt],kTErr[self.tt])
        
         self._MakeSkience()
        


    def ReadFluxFile(self,fluxFile):
        '''
        Reads an energy flux light curve file
        generated by the fluxLightCurve class

        
        '''
        eneSave = pickle.load(open(fluxFile))
        energyFlux_tot = eneSave['energy fluxes']["total"]
        energyFlux_bb = eneSave['energy fluxes']["Black Body"]
        energyFlux_totErr = eneSave['errors']["total"]
        energyFlux_bbErr = eneSave['errors']["Black Body"]


        self.energyFlux_tot = map(lambda v,e: self._Convert2Ufloat(v,e),energyFlux_tot[self.tt],energyFlux_totErr[self.tt])
        self.energyFlux_bb = map(lambda v,e: self._Convert2Ufloat(v,e),energyFlux_bb[self.tt],energyFlux_bbErr[self.tt])
    
        self._MakeSkience()

       


    def ReadFluxLightCurve(self,flc):
        '''
        Reads and FLC directly 
        
        '''
        energyFlux_tot = array(flc['energy fluxes']["total"])
        energyFlux_bb = array(flc['energy fluxes']["Black Body"])
        energyFlux_totErr = array(flc['errors']["total"])
        energyFlux_bbErr = array(flc['errors']["Black Body"])


        self.energyFlux_tot = map(lambda v,e: self._Convert2Ufloat(v,e),energyFlux_tot[self.tt],energyFlux_totErr[self.tt])
        self.energyFlux_bb = map(lambda v,e: self._Convert2Ufloat(v,e),energyFlux_bb[self.tt],energyFlux_bbErr[self.tt])

        self._MakeSkience()

    def _Convert2Ufloat(self,val,err):

        return ufloat((val,err))


    def _MakeSkience(self):


        self._ComputeScR()
        self._ComputeGamma()
        self._ComputeRph()



    def _ComputeScR(self):
        
        self.scR = []

        for bbF,kT in zip(self.energyFlux_bb,self.kT):


             r = (bbF/(sb*(kT*keV2erg/kb)**4))**0.5
             self.scR.append(r)




    def _ComputeGamma(self):


        self.Gamma = []

        for totF,bbF,kT,r in zip(self.energyFlux_tot,self.energyFlux_bb,self.kT,self.scR):

              gamma =(((1.06*(1+self.z)**2)*self.Ld*self.Y*totF*sigma_T)/(2*mp*(c**3)*r))**(0.25)

              self.Gamma.append(gamma)
        




    def _ComputeRph(self):


        self.Rph = []
        for gamma, r in zip(self.Gamma, self.scR):
        
            rph = r * self.Ld * gamma/(1.06* (1+self.z)**2 )
            
            self.Rph.append(rph)


        


    def _ComputeR0(self):


        pass



    def GetGamma(self):


        gam = map(lambda x: x.nominal_value, self.Gamma)
        gamErr = map(lambda x: x.std_dev(), self.Gamma)

        return [gam,gamErr]


    def GetRph(self):


        rph = map(lambda x: x.nominal_value, self.Rph)
        rphErr = map(lambda x: x.std_dev(), self.Rph)

        return [rph,rphErr]
